use std::collections::BTreeMap;

use crate::config::{GlobalConfig, ProjectConfig};
use crate::paths;

/// Parse a width string like "60%", "0.6", or "800px" into a KDL `default-column-width` line.
fn format_column_width(width: &str) -> Option<String> {
    let trimmed = width.trim();
    if let Some(pct) = trimmed.strip_suffix('%') {
        let val: f64 = pct.trim().parse().ok()?;
        let proportion = val / 100.0;
        Some(format!(
            "    default-column-width {{ proportion {proportion:.1}; }}\n"
        ))
    } else if let Some(px) = trimmed.strip_suffix("px") {
        let val: u32 = px.trim().parse().ok()?;
        Some(format!(
            "    default-column-width {{ fixed {val}; }}\n"
        ))
    } else if let Ok(val) = trimmed.parse::<f64>() {
        // Bare float treated as proportion
        Some(format!(
            "    default-column-width {{ proportion {val:.1}; }}\n"
        ))
    } else {
        None
    }
}

/// Map a terminal command name to its niri app-id regex.
fn terminal_app_id(terminal: &str) -> &str {
    match terminal {
        "ghostty" => "com\\.mitchellh\\.ghostty",
        "foot" => "foot",
        "alacritty" => "Alacritty",
        "kitty" => "kitty",
        "wezterm" => "org\\.wezfurlong\\.wezterm",
        _ => terminal,
    }
}

pub fn generate_niri_rules(projects: &[ProjectConfig], global: &GlobalConfig) -> String {
    let mut out = String::from("// Auto-generated by drift. Do not edit.\n");

    let mut grouped: BTreeMap<Option<&str>, Vec<&ProjectConfig>> = BTreeMap::new();
    for p in projects {
        let folder = p.project.folder.as_deref();
        grouped.entry(folder).or_default().push(p);
    }

    for (folder, mut configs) in grouped {
        configs.sort_by(|a, b| a.project.name.cmp(&b.project.name));

        out.push('\n');
        match folder {
            Some(name) => out.push_str(&format!("// {name}\n")),
            None => out.push_str("// (ungrouped)\n"),
        }

        for config in &configs {
            out.push_str(&format!("workspace \"{}\"\n", config.project.name));
        }

        for config in &configs {
            let name = &config.project.name;
            let terminal = terminal_app_id(&global.defaults.terminal);

            // Base rule: routes all drift windows for this project to its workspace.
            // The regex matches both "drift:name" and "drift:name/windowname".
            out.push_str(&format!(
                "\nwindow-rule {{\n    match app-id=r#\"^{terminal}$\"# title=r#\"^drift:{name}(/.*)?$\"#\n    open-on-workspace \"{name}\"\n}}\n"
            ));

            // Per-window rules with column width
            for window in &config.windows {
                let width_str = match &window.width {
                    Some(w) => w,
                    None => continue,
                };
                let width_line = match format_column_width(width_str) {
                    Some(line) => line,
                    None => continue,
                };
                let wn = match &window.name {
                    Some(n) => n,
                    None => continue,
                };
                out.push_str(&format!(
                    "\nwindow-rule {{\n    match app-id=r#\"^{terminal}$\"# title=r#\"^drift:{name}/{wn}$\"#\n{width_line}}}\n"
                ));
            }

            // Per-agent rules with column width
            if let Some(services) = &config.services {
                for svc in &services.processes {
                    if svc.agent.is_none() || svc.agent_mode != "interactive" {
                        continue;
                    }
                    let width_str = match &svc.width {
                        Some(w) => w,
                        None => continue,
                    };
                    let width_line = match format_column_width(width_str) {
                        Some(line) => line,
                        None => continue,
                    };
                    out.push_str(&format!(
                        "\nwindow-rule {{\n    match app-id=r#\"^{terminal}$\"# title=r#\"^drift:{name}/{}$\"#\n{width_line}}}\n",
                        svc.name
                    ));
                }
            }
        }
    }

    out
}

pub fn write_niri_rules(
    projects: &[ProjectConfig],
    global: &GlobalConfig,
) -> anyhow::Result<()> {
    let content = generate_niri_rules(projects, global);
    let path = paths::niri_rules_path();
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    std::fs::write(&path, content)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::{
        Defaults, EnvConfig, GlobalConfig, PortDefaults, ProjectConfig, ProjectMeta,
        ServicesConfig, ServiceProcess, RestartPolicy, WindowConfig,
    };

    fn make_global(terminal: &str) -> GlobalConfig {
        GlobalConfig {
            defaults: Defaults {
                terminal: terminal.into(),
                editor: "nvim".into(),
                shell: "zsh".into(),
            },
            ports: PortDefaults::default(),
            events: crate::config::EventsConfig::default(),
            commander: crate::config::CommanderConfig::default(),
        }
    }

    fn make_project(name: &str, folder: Option<&str>) -> ProjectConfig {
        ProjectConfig {
            project: ProjectMeta {
                name: name.into(),
                repo: format!("~/code/{name}"),
                folder: folder.map(String::from),
                icon: None,
            },
            env: EnvConfig::default(),
            git: None,
            ports: None,
            services: None,
            windows: vec![],
            scratchpad: None,
        }
    }

    #[test]
    fn no_projects_just_header() {
        let global = make_global("ghostty");
        let result = generate_niri_rules(&[], &global);
        assert_eq!(result, "// Auto-generated by drift. Do not edit.\n");
    }

    #[test]
    fn projects_in_same_folder() {
        let global = make_global("ghostty");
        let projects = vec![
            make_project("api", Some("backend")),
            make_project("web", Some("backend")),
        ];
        let result = generate_niri_rules(&projects, &global);
        assert!(result.contains("// backend\n"));
        assert!(result.contains("workspace \"api\"\n"));
        assert!(result.contains("workspace \"web\"\n"));
        assert!(result.contains(r##"match app-id=r#"^com\.mitchellh\.ghostty$"# title=r#"^drift:api(/.*)?$"#"##));
        assert!(result.contains(r##"match app-id=r#"^com\.mitchellh\.ghostty$"# title=r#"^drift:web(/.*)?$"#"##));
    }

    #[test]
    fn projects_in_different_folders() {
        let global = make_global("alacritty");
        let projects = vec![
            make_project("api", Some("backend")),
            make_project("dashboard", Some("frontend")),
        ];
        let result = generate_niri_rules(&projects, &global);
        assert!(result.contains("// backend\n"));
        assert!(result.contains("// frontend\n"));
        assert!(result.contains(r##"match app-id=r#"^Alacritty$"# title=r#"^drift:api(/.*)?$"#"##));
        assert!(result.contains(r##"match app-id=r#"^Alacritty$"# title=r#"^drift:dashboard(/.*)?$"#"##));
    }

    #[test]
    fn ungrouped_projects() {
        let global = make_global("ghostty");
        let projects = vec![
            make_project("standalone", None),
        ];
        let result = generate_niri_rules(&projects, &global);
        assert!(result.contains("// (ungrouped)\n"));
        assert!(result.contains("workspace \"standalone\"\n"));
    }

    #[test]
    fn mixed_grouped_and_ungrouped() {
        let global = make_global("ghostty");
        let projects = vec![
            make_project("loose", None),
            make_project("grouped", Some("mygroup")),
        ];
        let result = generate_niri_rules(&projects, &global);
        assert!(result.contains("// (ungrouped)\n"));
        assert!(result.contains("// mygroup\n"));
        assert!(result.contains("workspace \"loose\"\n"));
        assert!(result.contains("workspace \"grouped\"\n"));
    }

    #[test]
    fn window_rule_block_structure() {
        let global = make_global("ghostty");
        let projects = vec![make_project("proj", Some("g"))];
        let result = generate_niri_rules(&projects, &global);
        assert!(result.contains("window-rule {\n"));
        assert!(result.contains("    open-on-workspace \"proj\"\n"));
        assert!(result.contains("}\n"));
    }

    #[test]
    fn projects_sorted_within_folder() {
        let global = make_global("ghostty");
        let projects = vec![
            make_project("zebra", Some("animals")),
            make_project("alpha", Some("animals")),
        ];
        let result = generate_niri_rules(&projects, &global);
        let alpha_pos = result.find("workspace \"alpha\"").unwrap();
        let zebra_pos = result.find("workspace \"zebra\"").unwrap();
        assert!(alpha_pos < zebra_pos, "alpha should come before zebra");
    }

    #[test]
    fn window_with_percentage_width() {
        let global = make_global("ghostty");
        let mut proj = make_project("myapp", Some("dev"));
        proj.windows = vec![
            WindowConfig { name: Some("editor".into()), command: Some("nvim .".into()), width: Some("60%".into()) },
            WindowConfig { name: Some("shell".into()), command: None, width: Some("40%".into()) },
        ];
        let result = generate_niri_rules(&[proj], &global);
        assert!(result.contains(r##"match app-id=r#"^com\.mitchellh\.ghostty$"# title=r#"^drift:myapp/editor$"#"##));
        assert!(result.contains("default-column-width { proportion 0.6; }"));
        assert!(result.contains(r##"match app-id=r#"^com\.mitchellh\.ghostty$"# title=r#"^drift:myapp/shell$"#"##));
        assert!(result.contains("default-column-width { proportion 0.4; }"));
    }

    #[test]
    fn window_with_pixel_width() {
        let global = make_global("ghostty");
        let mut proj = make_project("myapp", None);
        proj.windows = vec![
            WindowConfig { name: Some("editor".into()), command: None, width: Some("800px".into()) },
        ];
        let result = generate_niri_rules(&[proj], &global);
        assert!(result.contains("default-column-width { fixed 800; }"));
    }

    #[test]
    fn window_without_width_no_column_rule() {
        let global = make_global("ghostty");
        let mut proj = make_project("myapp", None);
        proj.windows = vec![
            WindowConfig { name: Some("shell".into()), command: None, width: None },
        ];
        let result = generate_niri_rules(&[proj], &global);
        assert!(!result.contains("default-column-width"));
        // Should still have the base rule
        assert!(result.contains("open-on-workspace \"myapp\""));
    }

    #[test]
    fn agent_with_width() {
        let global = make_global("ghostty");
        let mut proj = make_project("myapp", None);
        proj.services = Some(ServicesConfig {
            processes: vec![ServiceProcess {
                name: "assistant".into(),
                command: String::new(),
                cwd: ".".into(),
                restart: RestartPolicy::OnFailure,
                stop_command: None,
                agent: Some("claude".into()),
                prompt: Some("Help me".into()),
                agent_mode: "interactive".into(),
                agent_model: None,
                agent_permissions: "full".into(),
                width: Some("50%".into()),
            }],
        });
        let result = generate_niri_rules(&[proj], &global);
        assert!(result.contains(r##"match app-id=r#"^com\.mitchellh\.ghostty$"# title=r#"^drift:myapp/assistant$"#"##));
        assert!(result.contains("default-column-width { proportion 0.5; }"));
    }

    #[test]
    fn non_interactive_agent_width_ignored() {
        let global = make_global("ghostty");
        let mut proj = make_project("myapp", None);
        proj.services = Some(ServicesConfig {
            processes: vec![ServiceProcess {
                name: "worker".into(),
                command: String::new(),
                cwd: ".".into(),
                restart: RestartPolicy::OnFailure,
                stop_command: None,
                agent: Some("claude".into()),
                prompt: Some("Do stuff".into()),
                agent_mode: "oneshot".into(),
                agent_model: None,
                agent_permissions: "full".into(),
                width: Some("50%".into()),
            }],
        });
        let result = generate_niri_rules(&[proj], &global);
        // oneshot agents don't get window rules since they aren't spawned as windows
        assert!(!result.contains("drift:myapp/worker"));
    }

    #[test]
    fn format_column_width_percentage() {
        assert_eq!(
            format_column_width("60%").unwrap(),
            "    default-column-width { proportion 0.6; }\n"
        );
    }

    #[test]
    fn format_column_width_pixels() {
        assert_eq!(
            format_column_width("800px").unwrap(),
            "    default-column-width { fixed 800; }\n"
        );
    }

    #[test]
    fn format_column_width_bare_float() {
        assert_eq!(
            format_column_width("0.5").unwrap(),
            "    default-column-width { proportion 0.5; }\n"
        );
    }

    #[test]
    fn format_column_width_invalid() {
        assert!(format_column_width("bogus").is_none());
    }
}
