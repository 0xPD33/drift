use std::collections::BTreeMap;

use crate::config::{GlobalConfig, ProjectConfig};
use crate::paths;

pub fn generate_niri_rules(projects: &[ProjectConfig], global: &GlobalConfig) -> String {
    let mut out = String::from("// Auto-generated by drift. Do not edit.\n");

    let mut grouped: BTreeMap<Option<&str>, Vec<&ProjectConfig>> = BTreeMap::new();
    for p in projects {
        let folder = p.project.folder.as_deref();
        grouped.entry(folder).or_default().push(p);
    }

    for (folder, mut configs) in grouped {
        configs.sort_by(|a, b| a.project.name.cmp(&b.project.name));

        out.push('\n');
        match folder {
            Some(name) => out.push_str(&format!("// {name}\n")),
            None => out.push_str("// (ungrouped)\n"),
        }

        for config in &configs {
            out.push_str(&format!("workspace \"{}\"\n", config.project.name));
        }

        for config in &configs {
            let name = &config.project.name;
            let terminal = &global.defaults.terminal;
            out.push_str(&format!(
                "\nwindow-rule {{\n    match app-id=r#\"^{terminal}$\"# title=r#\"^drift:{name}$\"#\n    open-on-workspace \"{name}\"\n}}\n"
            ));
        }
    }

    out
}

pub fn write_niri_rules(
    projects: &[ProjectConfig],
    global: &GlobalConfig,
) -> anyhow::Result<()> {
    let content = generate_niri_rules(projects, global);
    let path = paths::niri_rules_path();
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    std::fs::write(&path, content)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::{
        Defaults, EnvConfig, GlobalConfig, PortDefaults, ProjectConfig, ProjectMeta,
    };

    fn make_global(terminal: &str) -> GlobalConfig {
        GlobalConfig {
            defaults: Defaults {
                terminal: terminal.into(),
                editor: "nvim".into(),
                shell: "zsh".into(),
            },
            ports: PortDefaults::default(),
            events: crate::config::EventsConfig::default(),
        }
    }

    fn make_project(name: &str, folder: Option<&str>) -> ProjectConfig {
        ProjectConfig {
            project: ProjectMeta {
                name: name.into(),
                repo: format!("~/code/{name}"),
                folder: folder.map(String::from),
                icon: None,
            },
            env: EnvConfig::default(),
            git: None,
            ports: None,
            services: None,
            windows: vec![],
            scratchpad: None,
        }
    }

    #[test]
    fn no_projects_just_header() {
        let global = make_global("ghostty");
        let result = generate_niri_rules(&[], &global);
        assert_eq!(result, "// Auto-generated by drift. Do not edit.\n");
    }

    #[test]
    fn projects_in_same_folder() {
        let global = make_global("ghostty");
        let projects = vec![
            make_project("api", Some("backend")),
            make_project("web", Some("backend")),
        ];
        let result = generate_niri_rules(&projects, &global);
        assert!(result.contains("// backend\n"));
        assert!(result.contains("workspace \"api\"\n"));
        assert!(result.contains("workspace \"web\"\n"));
        assert!(result.contains(r##"match app-id=r#"^ghostty$"# title=r#"^drift:api$"#"##));
        assert!(result.contains(r##"match app-id=r#"^ghostty$"# title=r#"^drift:web$"#"##));
    }

    #[test]
    fn projects_in_different_folders() {
        let global = make_global("alacritty");
        let projects = vec![
            make_project("api", Some("backend")),
            make_project("dashboard", Some("frontend")),
        ];
        let result = generate_niri_rules(&projects, &global);
        assert!(result.contains("// backend\n"));
        assert!(result.contains("// frontend\n"));
        assert!(result.contains(r##"match app-id=r#"^alacritty$"# title=r#"^drift:api$"#"##));
        assert!(result.contains(r##"match app-id=r#"^alacritty$"# title=r#"^drift:dashboard$"#"##));
    }

    #[test]
    fn ungrouped_projects() {
        let global = make_global("ghostty");
        let projects = vec![
            make_project("standalone", None),
        ];
        let result = generate_niri_rules(&projects, &global);
        assert!(result.contains("// (ungrouped)\n"));
        assert!(result.contains("workspace \"standalone\"\n"));
    }

    #[test]
    fn mixed_grouped_and_ungrouped() {
        let global = make_global("ghostty");
        let projects = vec![
            make_project("loose", None),
            make_project("grouped", Some("mygroup")),
        ];
        let result = generate_niri_rules(&projects, &global);
        assert!(result.contains("// (ungrouped)\n"));
        assert!(result.contains("// mygroup\n"));
        assert!(result.contains("workspace \"loose\"\n"));
        assert!(result.contains("workspace \"grouped\"\n"));
    }

    #[test]
    fn window_rule_block_structure() {
        let global = make_global("ghostty");
        let projects = vec![make_project("proj", Some("g"))];
        let result = generate_niri_rules(&projects, &global);
        assert!(result.contains("window-rule {\n"));
        assert!(result.contains("    open-on-workspace \"proj\"\n"));
        assert!(result.contains("}\n"));
    }

    #[test]
    fn projects_sorted_within_folder() {
        let global = make_global("ghostty");
        let projects = vec![
            make_project("zebra", Some("animals")),
            make_project("alpha", Some("animals")),
        ];
        let result = generate_niri_rules(&projects, &global);
        let alpha_pos = result.find("workspace \"alpha\"").unwrap();
        let zebra_pos = result.find("workspace \"zebra\"").unwrap();
        assert!(alpha_pos < zebra_pos, "alpha should come before zebra");
    }
}
